import com.ngc.seaside.jellyfish.cli.gradle.tasks.JellyFishCliCommandTask
import com.ngc.seaside.jellyfish.examples.tasks.BuildScriptUpdater
import com.ngc.seaside.jellyfish.examples.tasks.RegressionDiffTask
import groovy.io.FileType
import groovy.io.FileVisitResult

buildscript {
   ext {
      versionsFile = file('../versions.gradle')
      buildScriptUpdater = new BuildScriptUpdater()
   }
   apply from: versionsFile, to: project

   repositories {
      mavenLocal()

      maven {
         url nexusConsolidated
      }
   }

   dependencies {
      classpath "com.ngc.seaside:gradle.plugins:$seasidePluginsVersion"
      classpath "org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:$sonarqubePluginVersion"
      classpath "com.ngc.seaside:jellyfish.cli.gradle.plugins:$version"
   }
}

apply plugin: 'com.ngc.seaside.release.root'
apply plugin: 'com.ngc.seaside.parent'

versionSettings {
   versionFile = versionsFile
}

ext {
   systemDescriptorProjectsFolderName = 'system-descriptor-projects'
   regressionsFolderName = 'regressions'
   generatedFolderName = 'generatedOutput'
   expectedFolderName = 'expectedOutput'
}

gradle.buildFinished {
   buildScriptUpdater.restoreAllScripts()
}

task('cleanSystemDescriptorProjects', description: 'cleans all of the system descriptor projects') {
   clean.dependsOn it
}

task('buildSystemDescriptorProjects', description: 'builds and installs all of the system descriptor projects') {
   build.dependsOn it
}

file(systemDescriptorProjectsFolderName).eachDir { folder ->
   def sdProjectName = folder.name.capitalize()
   task("cleanSd${sdProjectName}",
        type: Delete,
        description: "Cleans the system descriptor project ${sdProjectName}") {
      folder.traverse(type: groovy.io.FileType.DIRECTORIES, maxDepth: 3, visitRoot: true) {
         if (it.name == 'build') {
            delete it
            return groovy.io.FileVisitResult.SKIP_SIBLINGS
         }
         if (it.name == 'src') {
            return groovy.io.FileVisitResult.SKIP_SIBLINGS
         }
      }
      cleanSystemDescriptorProjects.dependsOn it
   }
   task("buildSd${sdProjectName}",
        type: GradleBuild,
        description: "Runs 'gradle build install' on the system descriptor project ${sdProjectName}") {
      dir = folder
      tasks = ['build', 'install']
      startParameter.projectProperties['jellyfishCliVersion'] = version

      buildSystemDescriptorProjects.dependsOn it
      if (name != 'buildSdThreat-eval-system-descriptor') {
         project.afterEvaluate {
            dependsOn project.tasks['buildSdThreat-eval-system-descriptor']
         }
      } 
   }
}

task('cleanRegressions', description: 'Cleans the build and generated folders for all regressions') {
   clean.dependsOn it
}

task('generateRegressions', description: 'Generates the output for all regressions', group: 'Regression')
task('buildRegressions', description: 'Builds the generated output for all regressions', group: 'Regression')
task('updateExpectedRegressions',
     description: 'Replaces the expected output with the generated output for all regressions', group: 'Regression')

file(regressionsFolderName).eachDir { folder ->
   def regressionName = folder.name.capitalize()
   def expectedFolder = file("${folder}/${expectedFolderName}")
   def generatedFolder = file("${folder}/${generatedFolderName}")
   def tempFolder = java.nio.file.Files.createTempDirectory(null).toFile()

   // Clean build folders and generated folder
   task("cleanRegression${regressionName}",
        description: "Cleans the build and generated folder for regression ${regressionName}") {
      delete generatedFolder
      expectedFolder.traverse(type: groovy.io.FileType.DIRECTORIES, maxDepth: 3, visitRoot: true) {
         if (it.name == 'build') {
            delete it
            return groovy.io.FileVisitResult.SKIP_SIBLINGS
         }
         if (it.name == 'src') {
            return groovy.io.FileVisitResult.SKIP_SIBLINGS
         }
      }
      cleanRegressions.dependsOn it
   }

   // Update the Jellyfish version referenced in the expected project.
   def updateVersionTask = createUpdateExpectedJellyfishVersion("updateExpectedJellyfishVersion${regressionName}",
                                                                expectedFolder)

   // Generate project using jellyfish cli
   def generateTask = createGenerationTask("generateRegression${regressionName}", folder, regressionName)
   generateTask.dependsOn buildSystemDescriptorProjects
   generateRegressions.dependsOn generateTask

   // Build the generated project
   def buildTask = createRegressionBuildTask("buildRegression${regressionName}", folder, generatedFolder, tempFolder)
   buildTask.description = "Builds the generated regression ${regressionName}"
   buildTask.dependsOn buildSystemDescriptorProjects, generateTask
   buildRegressions.dependsOn buildTask

   // Diff the expected and generated projects
   def diffTask = task("diffRegression${regressionName}",
                       dependsOn: [updateVersionTask, generateTask],
                       type: RegressionDiffTask,
                       description: "Compares the expected and generated output for regression ${regressionName}") {
      regression = regressionName
      expectedDir = expectedFolder
      generatedDir = generatedFolder
   }

   task("regression${regressionName}",
        group: test.group,
        description: "Runs the entire regression test ${regressionName}",
        dependsOn: [generateTask, buildTask, diffTask]) {

      test.dependsOn it
   }

   task("updateExpectedRegression${regressionName}",
        dependsOn: generateTask,
        description: "Replaces the expected output with the generated output for regression ${regressionName}") {
      doLast {
         delete expectedFolder
         copy {
            from generatedFolder
            into expectedFolder
         }
      }
      updateExpectedRegressions.dependsOn it
   }

   task("audit${regressionName}",
        dependsOn: buildTask,
        group: "Auditing and Security",
        description: "Collects all dependencies used by project generated for regression ${regressionName}",
        type: GradleBuild) {
      doFirst {
         dir = tempFolder
      }

      String cleanSnapshots = project.hasProperty('removeSnapshots') ? project.property('removeSnapshots') : 'false'
      tasks = ['populateM2repo',
               '--outputDirectory',
               m2directory.getAbsolutePath(),
               '--dependencyInfoReportFile',
               dependenciesReportFile.getAbsolutePath(),
               '--deploymentScriptFile',
               m2DeploymentScriptFile.getAbsolutePath(),
               '--removeSnapshots',
               cleanSnapshots]
      startParameter.systemPropertiesArgs = [:]
   }
}

// Creates a task that will generate the regression output, with the given task name, regression folder, and regression name
def createGenerationTask(name, folder, regressionName) {
   def propertiesFile = file("${folder}/jellyfish.properties")
   if (!propertiesFile.isFile()) {
      throw new GradleException("Regression ${regressionName} is missing jellyfish.properties file")
   }

   Properties properties = new Properties()
   propertiesFile.withInputStream {
      properties.load(it)
   }

   properties['outputDirectory'] = "${folder}/${generatedFolderName}"
   properties['clean'] = 'true'
   if (properties.containsKey('inputDirectory')) {
      properties['inputDirectory'] = file("${systemDescriptorProjectsFolderName}/${properties['inputDirectory']}").absolutePath
   }

   def generateTask = task(name,
                           type: JellyFishCliCommandTask,
                           description: "Generates the output for regression ${regressionName}") {
      command = properties['command']
      arguments = properties
   }
   return generateTask
}

/**
 * Creates a task that will update the Jellyfish version of the expected project to the current Jellyfish version.
 * @param name the name of the task
 * @param folder the folder that contains the build.gradle script to update
 * @return the task
 */
def createUpdateExpectedJellyfishVersion(name, folder) {
   def versionTask = task(name) {
      doLast {
         folder.traverse(type: groovy.io.FileType.DIRECTORIES, maxDepth: 3) { buildFolder ->
            if (file("${buildFolder}/build.gradle").isFile()) {
               def buildFile = file("${buildFolder}/build.gradle")
               buildScriptUpdater.updateJellyFishGradlePluginsVersion(buildFile.toPath(), version)
               return groovy.io.FileVisitResult.SKIP_SIBLINGS
            }
         }
      }
   }
   return versionTask
}

// Creates a task to build a gradle project. This task will search sub-directories until it finds a build.gradle.
// This task will also copy the folder to a temp directory to fix windows path length issues
def createRegressionBuildTask(name, regressionFolder, folder, tempDirectory) {
   def propertiesFile = file("${regressionFolder}/build_regression.properties")
   def extraProperties = [:]
   if (propertiesFile.isFile()) {
      Properties properties = new Properties()
      propertiesFile.withInputStream {
         properties.load(it)
      }
      extraProperties << properties
   }

   def buildTask = task(name) {
      doLast {
         folder.traverse(type: groovy.io.FileType.DIRECTORIES, maxDepth: 3) { buildFolder ->
            if (file("${buildFolder}/build.gradle").isFile()) {
               copy {
                  from buildFolder
                  into tempDirectory
               }

               def gradleBuildTask = task(type: GradleBuild) {}
               gradleBuildTask.dir = tempDirectory
               gradleBuildTask.tasks = ['clean', 'build']
               gradleBuildTask.startParameter.excludedTaskNames = ['test']
               gradleBuildTask.startParameter.systemPropertiesArgs = [:]
               gradleBuildTask.startParameter.projectProperties << extraProperties
               gradleBuildTask.execute()

               return groovy.io.FileVisitResult.SKIP_SIBLINGS
            }
         }
      }
   }
   return buildTask
}
