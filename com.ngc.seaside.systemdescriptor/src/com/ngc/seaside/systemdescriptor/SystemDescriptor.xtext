grammar com.ngc.seaside.systemdescriptor.SystemDescriptor
with org.eclipse.xtext.common.Terminals
hidden (WS, ML_COMMENT, SL_COMMENT, SL_EXTENDED_COMMENT)


generate systemDescriptor "http://www.ngc.com/seaside/systemdescriptor/SystemDescriptor"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

/*
 * Package is the root type and it contains imports and at most one declaration of
 * an element.  Should align to the decomposition of the system. The structure here
 * should reflect the file structure similar to that of Java.
 */
Package
	: 'package' name=QualifiedName
	  imports+=Import*
	  element=Element
	;

/*
 * A comment may also begin with '--'.  It is ignored.
 */
terminal SL_EXTENDED_COMMENT
	: '--' !('\n'|'\r')* ('\r'? '\n')?
	;

// -------------------------------	
// ---- Identifiers and names ----
// -------------------------------

/*
 * A qualified name is a '.' delimited set of IDs.
 */
QualifiedName
	: ID ('.' ID)*
	;

/*
 * A qualified name with a wildcard is normal Java like import with
 * some.name.*
 */
QualifiedNameWithWildcard
	: QualifiedName '.*'?
	;

/*
 * An unqualified name is just an identifier without any '.' delimiters.
 */	
UnqualifiedName
	: ID
	;

// ---------------------------
// ---- Common base types ----
// ---------------------------

/*
 * FieldDeclaration is the base type of all type of declarations in a model.
 * This includes inputs, outputs, parts, and requirements.
 * 
 * This element is used in references.
 */
FieldDeclaration
	: InputDeclaration
	| OutputDeclaration
	| PartDeclaration
	| RequireDeclaration
	;

// ---------------------------
// ---- Package structure ----
// ---------------------------

/*
 * Imports allow modelers to reference data or models in other packages.
 * Note that wildcard ('*') imports are not yet supported.
 */
Import
	: 'import' importedNamespace=[Element|QualifiedName]
	;


// ------------------------------
// ---- Data related objects ----
// ------------------------------

/*
 * Defines the different data types that are built in.
 */
enum DataType
	: INT='int'
	| FLOAT='float'
	| STRING="string"
	| BOOLEAN="boolean"
	;
	
/*
 * A data field declaration consists of a type and unqualified name.
 * It may also contain optional metadata.
 */
DataFieldDeclaration
	: type=DataType
	  name=UnqualifiedName
	  metadata=JsonObject?
	;

// -------------------------------
// ---- Model related objects ----
// -------------------------------

/*
 * Defines different cardinality values.
 * 
 * Note the first value of a enum is the default value that the parsed 
 * model will have.  Since cardinality is optional for inputs and 
 * outputs we have to make sure we have a default value listed first
 * that means not set.
 */
enum Cardinality
    : DEFAULT='default'
	| MANY='many'
	;

/*
 * Declares a output via a referenced data type and an unqualified name.
 * An output declaration may also specify an optional cardinality.
 */
OutputDeclaration
	: cardinality=Cardinality? type=[Data|UnqualifiedName] name=UnqualifiedName
	;

/*
 * Optional attribute of model, defines outputs produced by the model.
 */
Output
	: 'output' '{'
		declarations+=OutputDeclaration+
	  '}'
	;

/*
 * Declares an input via a referenced data type and an unqualified name.
 * An output declaration may also specify an optional cardinality.
 */
InputDeclaration
	: cardinality=Cardinality? type=[Data|UnqualifiedName] name=UnqualifiedName
	;

/*
 * Optional attribute of a model, defines necessary input.
 */
Input 
	: 'input' '{'
		declarations+=InputDeclaration+
	  '}'
	; 

/*
 * Declares a sub-part of a model via a referenced model type and an unqualified name.
 */
PartDeclaration
	: type=[Model|UnqualifiedName] name=UnqualifiedName
	;
 
/*
 * Optional attribute of a model, defines sub-model objects.
 */
Parts
	: 'parts' '{'
		declarations+=PartDeclaration+
	  '}'
	;
 
/*
 * Declares a requirement on another model via a referenced model type
 * and an unqualified name.
 */
RequireDeclaration
	: type=[Model|UnqualifiedName] name=UnqualifiedName
	;
 
/*
 * Optional attribute of a model, places condition on the model to necessitate
 * access to / existence of another model. 
 */
Requires
	: 'requires' '{'
		declarations+=RequireDeclaration+
	  '}'
	;
 
// ----------------------------------
// ---- Scenario related objects ----
// ----------------------------------

/*
 * Declares a precondition that is associated with a given declaration.
 * The precondition can be any value but there must be some keyword
 * "handler" registered to interpret it.  Preconditions are usually
 * expressed as past tense verbs.  
 * 
 * A precondiion is basically a special case of a scenario keyword.
 */
Precondition
	: ID
	;

/*
 * Declares a generic keyword for use by a scenario.  These keywords
 * are usually verbs.  Keywords that are used in "whens" are usually 
 * in current tense.  Keywords that are used in "thens" are usually
 * in future tense.  The keyword can be any value but there must be 
 * a "handler" registered to interpret it.
 */
ScenarioKeyword
	: ID
	;

/*
 * Declares a generic parameter that is used by a particular keyword.
 */
ScenarioParameter
	: ID
	;

/*
 * The subject of a precondition expressed in a given declaration.
 * This is its own rule so we can later define additional types of
 * subjects, not just input fields.
 */
GivenSubject
	: input=[InputDeclaration]
	;

/*
 * Represents both a precondition and its subject.
 */
GivenFragment
	: subject=GivenSubject precondition=Precondition
	;

/*
 * Introduces a post condition that must be satisfied prior to the scenario being executable.
 */
GivenDeclaration
	: 'given' fragments+=GivenFragment
	  ('and' fragments+=GivenFragment)*
	;

/*
 * Represents both a triggering condition represented as a keyword and the parameters 
 * used by that keyword.
 */
WhenFragment
	: keyword=ScenarioKeyword (parameters+=ScenarioParameter)*
	;

/*
 * Introduces a condition or trigger to be tested that determines the scenario has began.
 */
WhenDeclaration
	: 'when' fragments+=WhenFragment
	  ('and' fragments+=WhenFragment)*
	;

/*
 * Represents both a postcondition represented as a keyword and the parameters 
 * used by that keyword.
 */
ThenFragment
	: keyword=ScenarioKeyword (parameters+=ScenarioParameter)*
	;

/*
 * Introduces a statement or post condition to be asserted after a scenario has been
 * triggered and has executed.
 */
ThenDeclaration
	: 'then' fragments+=ThenFragment
	  ('and' fragments+=ThenFragment)*
	;

/*
 * Attribute of a model defining a set of circumstances describing behavior the
 * model exhibits given a set of conditions. This should follow the BDD
 * specification syntax and use the keywords such as given, when and then.
 */
Scenario
	: 'scenario' name=UnqualifiedName '{'
		(
			given=GivenDeclaration?
		 	when=WhenDeclaration
		 	then=ThenDeclaration
		 )?
	  '}'
	;
	
// -----------------------------
// ---- Link model elements ----
// -----------------------------

/*
 * A linkable expression is an expression that is used in the link block.  
 * 
 * This syntax instructs XText to generate a base type named LinkableReference and
 * both LinkableExpression and FieldReference extend this base type.  The magic
 * LinkableExpression.ref=current statement results in a type of recursive tree 
 * structure that results in tree like structure.  The tail attribute is the 
 * final field in the expression and it must be a field.  
 * 
 * See
 * https://christiandietrich.wordpress.com/2013/05/18/xtext-and-dot-expressions/
 * for more information.
 */
LinkableExpression returns LinkableReference
	: FieldReference ({LinkableExpression.ref=current} '.' tail=[FieldDeclaration|UnqualifiedName])*
	;

/*
 * A field reference references a field declared in a model (which may be an
 * input, output, part, or requirement).
 */
FieldReference returns LinkableReference
	: {FieldReference} fieldDeclaration=[FieldDeclaration|UnqualifiedName]
	;	

/*
 * Provides a linkage between two objects, indicating that two objects interact or
 * exchange information in some manner (ex. "link speaker to alarm.speaker").
 */
LinkDeclaration
	: 'link' source=LinkableExpression 'to' target=LinkableExpression
	;

/*
 * Defines links in a model.
 */
Links
	: 'links' '{'
		declarations+=LinkDeclaration+
	  '}'
	;
 
// ------------------------------
// ---- Basic model elements ----
// ------------------------------

/*
 * Declares an object of data type; a type of object that contains attributes
 * of metadata and optional members.
 */
Data
	: 'data' name=UnqualifiedName '{'
		metadata=Metadata?
		fields+=DataFieldDeclaration*
	  '}'
	;

/*
 * Declares an object of model type; a type of object that contains attributes
 * of metadata and optional requires, input, output, and scenario attributes.
 */
Model
	: 'model' name=UnqualifiedName '{'
		metadata=Metadata?
		requires=Requires?
		input=Input?
		output=Output?
		scenarios+=Scenario*
		parts=Parts?
		links=Links?
	  '}'
	;

/*
 * An element represents the common root type of modeling elements.  Elements
 * may either be data or a model.
 */
Element
	: Data
	| Model
	;

/*
 * Optional attribute of model, data, input, and data. The metadata should 
 * use the JSON syntax. The modeler can use this field in any way necessary
 * to convey the intent of the object.  For instance: the model may require
 * metdata that provides a name, description and a classifier (stereotype)
 * in order to give the reader context.  Possible stereotypes include but
 * are not limited to:
 * - service (a service in the MSA architecture)
 * - virtual (a non-realized component used to convey structure)
 */
Metadata
	: 'metadata' json=JsonObject
	;	
	
// ----------------------
// ---- JSON support ----
// ----------------------

JsonObject:
	'{' {JsonObject}
	    ((members+=Member)
	    (',' members+=Member)*)?
    '}';

    
Member:
	key=STRING ':' value=Value;

StringValue: value=STRING;
BooleanValue: value=Boolean;
JsonValue: value=JsonObject;
ArrayValue: value=Array;
NullValue: value=Null;
IntValue: value=INTEGER;
DblValue: value=DOUBLE;

Value:
	StringValue | BooleanValue | JsonValue | ArrayValue | NullValue | IntValue | DblValue;

//Value:
//	JsonObject | STRING | Array | Boolean | Null | NUMBER;

Array:
	'[' {Array} 
	    ((values+=Value)  
	    (',' values+=Value)*)? 
	']';
	
Boolean:
	'true' | 'false';
	
Null:
	'null';
	
terminal INTEGER returns ecore::EInt:
	'-'? INT;

terminal DOUBLE returns ecore::EDouble:
	'-'? INT? '.' INT (('E'|'e') '-'? INT)?;
