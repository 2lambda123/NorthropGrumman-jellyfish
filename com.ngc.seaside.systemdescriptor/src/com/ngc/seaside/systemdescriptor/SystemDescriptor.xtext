grammar com.ngc.seaside.systemdescriptor.SystemDescriptor
with org.eclipse.xtext.common.Terminals
hidden (WS, ML_COMMENT, SL_COMMENT, SL_EXTENDED_COMMENT)


generate systemDescriptor "http://www.ngc.com/seaside/systemdescriptor/SystemDescriptor"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

/*
 * Package is the root type and it contains imports and at most one declaration of
 * an element.  Should align to the decomposition of the system. The structure here
 * should reflect the file structure similar to that of Java.
 */
Package
	: 'package' name=QualifiedName
	  imports+=Import*
	  element=Element
	;

/*
 * A comment may also begin with '--'.  It is ignored.
 */
terminal SL_EXTENDED_COMMENT
	: '--' !('\n'|'\r')* ('\r'? '\n')?
	;

// -------------------------------	
// ---- Identifiers and names ----
// -------------------------------

/*
 * A qualified name is a '.' delimited set of IDs.
 */
QualifiedName
	: ID ('.' ID)*
	;

/*
 * A qualified name with a wildcard is normal Java like import with
 * some.name.*
 */
QualifiedNameWithWildcard
	: QualifiedName '.*'?
	;

/*
 * An unqualified name is just an identifier without any '.' delimiters.
 */	
UnqualifiedName
	: ID
	;

// ---------------------------
// ---- Package structure ----
// ---------------------------

/*
 * Imports allow modelers to reference data or models in other packages.
 * Note that wildcard ('*') imports are not yet supported.
 */
Import
	: 'import' importedNamespace=[Element|QualifiedName]
	;


// ------------------------------
// ---- Data related objects ----
// ------------------------------

/*
 * Defines the different data types that are built in.
 */
enum DataType
	: INT='int'
	| FLOAT='float'
	| STRING="string"
	| BOOLEAN="boolean"
	;
	
/*
 * A data field declaration consists of a type and unqualified name.
 * It may also contain optional metadata.
 */
DataFieldDeclaration
	: type=DataType
	  name=UnqualifiedName
	  metadata=JsonObject?
	;

// -------------------------------
// ---- Model related objects ----
// -------------------------------

/*
 * Defines different cardinality values.
 * 
 * Note the first value of a enum is the default value that the parsed 
 * model will have.  Since cardinality is optional for inputs and 
 * outputs we have to make sure we have a default value listed first
 * that means not set.
 */
enum Cardinality
    : DEFAULT='default'
	| MANY='many'
	;

/*
 * Declares a output via a referenced data type and an unqualified name.
 * An output declaration may also specify an optional cardinality.
 */
OutputDeclaration
	: cardinality=Cardinality? type=[Data|UnqualifiedName] name=UnqualifiedName
	;

/*
 * Declares an input via a referenced data type and an unqualified name.
 * An output declaration may also specify an optional cardinality.
 */
InputDeclaration
	: cardinality=Cardinality? type=[Data|UnqualifiedName] name=UnqualifiedName
	;

/*
 * Optional attribute of model, defines outputs produced by the model.
 */
Output
	: 'output' '{'
		declarations+=OutputDeclaration+
	  '}'
	;

/*
 * Optional attribute of a model, defines necessary input.
 */
Input 
	: 'input' '{'
		declarations+=InputDeclaration+
	  '}'
	; 

/*
 * Declares a sub-part of a model via a referenced model type and an unqualified name.
 */
PartDeclaration
	: type=[Model|UnqualifiedName] name=UnqualifiedName
	;
 
/*
 * Optional attribute of a model, defines sub-model objects.
 */
Parts
	: 'parts' '{'
		declarations+=PartDeclaration+
	  '}'
	;
 
/*
 * Declares a requirement on another model via a referenced model type
 * and an unqualified name.
 */
RequireDeclaration
	: type=[Model|UnqualifiedName] name=UnqualifiedName
	;
 
/*
 * Optional attribute of a model, places condition on the model to necessitate
 * access to / existence of another model. 
 */
Requires
	: 'requires' '{'
		declarations+=RequireDeclaration+
	  '}'
	;
 
// -----------------------------------
// ---- Scenario releated objects ----
// -----------------------------------

Precondition
	: ID
	;

TriggeringCondition
	: ID
	;

Postcondition
	: 'bar'
	;

GivenSubject
	: input=[InputDeclaration]
	;

GivenFragment
	: subject=GivenSubject precondition=Precondition
	;

GivenDeclaration
	: 'given' fragments+=GivenFragment
	  ('and' fragments+=GivenFragment)*
	;

WhenSubject
	: input=[InputDeclaration]
	;

WhenFragment
	: triggeringCondition=TriggeringCondition subject=WhenSubject
	;

WhenDeclaration
	: 'when' fragments+=WhenFragment
	  ('and' fragments+=WhenFragment)*
	;


/*
 * Attribute of a model defining a set of circumstances describing behavior the
 * model exhibits given a set of conditions. This should follow the BDD
 * specification syntax and use the keywords such as given, when and then.
 */
Scenario
	: 'scenario' name=UnqualifiedName '{'
		given=GivenDeclaration?
		when=WhenDeclaration
	  '}'
	;
 
// ------------------------------
// ---- Basic model elements ----
// ------------------------------

/*
 * Declares an object of data type; a type of object that contains attributes
 * of metadata and optional members.
 */
Data
	: 'data' name=UnqualifiedName '{'
		metadata=Metadata?
		fields+=DataFieldDeclaration*
	  '}'
	;

/*
 * Declares an object of model type; a type of object that contains attributes
 * of metadata and optional requires, input, output, and scenario attributes.
 */
Model
	: 'model' name=UnqualifiedName '{'
		metadata=Metadata?
		requires=Requires?
		input=Input?
		output=Output?
		scenarios+=Scenario*
		parts=Parts?
	  '}'
	;

/*
 * An element represents the common root type of modeling elements.  Elements
 * may either be data or a model.
 */
Element
	: Data
	| Model
	;

/*
 * Optional attribute of model, data, input, and data. The metadata should 
 * use the JSON syntax. The modeler can use this field in any way necessary
 * to convey the intent of the object.  For instance: the model may require
 * metdata that provides a name, description and a classifier (stereotype)
 * in order to give the reader context.  Possible stereotypes include but
 * are not limited to:
 * - service (a service in the MSA architecture)
 * - virtual (a non-realized component used to convey structure)
 */
Metadata
	: 'metadata' json=JsonObject
	;	
	
// ----------------------
// ---- JSON support ----
// ----------------------

JsonObject:
	'{' {JsonObject}
	    ((members+=Member)
	    (',' members+=Member)*)?
    '}';

    
Member:
	key=STRING ':' value=Value;

StringValue: value=STRING;
BooleanValue: value=Boolean;
JsonValue: value=JsonObject;
ArrayValue: value=Array;
NullValue: value=Null;
IntValue: value=INTEGER;
DblValue: value=DOUBLE;

Value:
	StringValue | BooleanValue | JsonValue | ArrayValue | NullValue | IntValue | DblValue;

//Value:
//	JsonObject | STRING | Array | Boolean | Null | NUMBER;

Array:
	'[' {Array} 
	    ((values+=Value)  
	    (',' values+=Value)*)? 
	']';
	
Boolean:
	'true' | 'false';
	
Null:
	'null';
	
terminal INTEGER returns ecore::EInt:
	'-'? INT;

terminal DOUBLE returns ecore::EDouble:
	'-'? INT? '.' INT (('E'|'e') '-'? INT)?;
