grammar com.ngc.seaside.systemdescriptor.SystemDescriptor with org.eclipse.xtext.common.Terminals

generate systemDescriptor "http://www.ngc.com/seaside/systemdescriptor/SystemDescriptor"

/*
 * Package is the root type and it contains imports and at most one declaration of
 * an element.  Should align to the decomposition of the system. The structure here
 * should reflect the file structure similar to that of Java.
 */
Package
	: 'package' name=QualifiedName
	  imports+=Import*
	  element=Element
	;

// -------------------------------	
// ---- Identifiers and names ----
// -------------------------------

/*
 * A qualified name is a '.' delimited set of IDs.
 */
QualifiedName
	: ID ('.' ID)*
	;

/*
 * A qualified name with a wildcard is normal Java like import with
 * some.name.*
 */
QualifiedNameWithWildcard
	: QualifiedName '.*'?
	;

/*
 * An unqualified name is just an identifier without any '.' delimiters.
 */	
UnqualifiedName
	: ID
	;

// ---------------------------
// ---- Package structure ----
// ---------------------------

/*
 * Imports allow modelers to reference data or models in other packages.
 * Note that wildcard ('*') imports are not yet supported.
 */
Import
	: 'import' importedNamespace=[Element|QualifiedName]
	;


// ------------------------------
// ---- Data related objects ----
// ------------------------------

/*
 * Defines the different data types that are built in.
 */
enum DataType
	: INT='int'
	| FLOAT='float'
	| STRING="string"
	| BOOLEAN="boolean"
	;
	
/*
 * A data field declaration consists of a type and unqualified name.
 * It may also contain optional metadata.
 */
DataFieldDeclaration
	: type=DataType
	  name=UnqualifiedName
	  metadata=JsonObject?
	;

// -------------------------------
// ---- Model related objects ----
// -------------------------------

/*
 * Declares a output via a referenced data type and an unqualified name.
 */
OutputDeclaration
	: type=[Data|UnqualifiedName] name=UnqualifiedName
	;

/*
 * Declares an input via a referenced data type and an unqualified name.
 */
InputDeclaration
	: type=[Data|UnqualifiedName] name=UnqualifiedName
	;

/*
 * Optional attribute of model, defines outputs produced by the model.
 */
Output
	: 'output' '{'
		declarations+=OutputDeclaration+
	  '}'
	;

/*
 * Optional attribute of a model, defines necessary input.
 */
Input 
	: 'input' '{'
		declarations+=InputDeclaration+
	  '}'
	; 

/*
 * Declares a sub-part of a model via a referenced model type and an unqualified name.
 */
PartDeclaration
	: type=[Model|UnqualifiedName] name=UnqualifiedName
	;
 
/*
 * Optional attribute of a model, defines sub-model objects.
 */
Parts
	: 'parts' '{'
		parts+=PartDeclaration+
	  '}'
	;
 
// ------------------------------
// ---- Basic model elements ----
// ------------------------------

/*
 * Declares an object of data type; a type of object that contains attributes
 * of metadata and optional members.
 */
Data
	: 'data' name=UnqualifiedName '{'
		metadata=Metadata?
		fields+=DataFieldDeclaration*
	  '}'
	;

/*
 * Declares an object of model type; a type of object that contains attributes
 * of metadata and optional requires, input, output, and scenario attributes.
 */
Model
	: 'model' name=UnqualifiedName '{'
		metadata=Metadata?
		input=Input?
		output=Output?
		parts=Parts?
	  '}'
	;

/*
 * An element represents the common root type of modeling elements.  Elements
 * may either be data or a model.
 */
Element
	: Data
	| Model
	;

/*
 * Optional attribute of model, data, input, and data. The metadata should 
 * use the JSON syntax. The modeler can use this field in any way necessary
 * to convey the intent of the object.  For instance: the model may require
 * metdata that provides a name, description and a classifier (stereotype)
 * in order to give the reader context.  Possible stereotypes include but
 * are not limited to:
 * - service (a service in the MSA architecture)
 * - virtual (a non-realized component used to convey structure)
 */
Metadata
	: 'metadata' json=JsonObject?
	;	
	
// ----------------------
// ---- JSON support ----
// ----------------------

JsonObject:
	'{'
	firstObject=TerminalObject (',' objects+=TerminalObject)* '}';

Array:
	'[' firstItem=ObjectValue (',' items+=ObjectValue)* ']';

EmptyObject:
	isEmpty?='{}';

EmptyArray:
	isEmpty?='[]';

ObjectValue:
	value=STRING | JsonObject | Array | EmptyObject | EmptyArray;

TerminalObject:
    element=STRING ':' (content=ObjectValue);
