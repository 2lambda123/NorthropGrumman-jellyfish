/*
 * generated by Xtext 2.10.0
 */
package com.ngc.seaside.systemdescriptor.serializer;

import com.google.inject.Inject;
import com.ngc.seaside.systemdescriptor.services.SystemDescriptorGrammarAccess;
import com.ngc.seaside.systemdescriptor.systemDescriptor.Array;
import com.ngc.seaside.systemdescriptor.systemDescriptor.Data;
import com.ngc.seaside.systemdescriptor.systemDescriptor.Descriptor;
import com.ngc.seaside.systemdescriptor.systemDescriptor.EmptyArray;
import com.ngc.seaside.systemdescriptor.systemDescriptor.EmptyObject;
import com.ngc.seaside.systemdescriptor.systemDescriptor.Import;
import com.ngc.seaside.systemdescriptor.systemDescriptor.Metadata;
import com.ngc.seaside.systemdescriptor.systemDescriptor.Model;
import com.ngc.seaside.systemdescriptor.systemDescriptor.ObjectValue;
import com.ngc.seaside.systemdescriptor.systemDescriptor.SystemDescriptorPackage;
import com.ngc.seaside.systemdescriptor.systemDescriptor.TerminalObject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SystemDescriptorSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SystemDescriptorGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SystemDescriptorPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SystemDescriptorPackage.ARRAY:
				sequence_Array(context, (Array) semanticObject); 
				return; 
			case SystemDescriptorPackage.DATA:
				sequence_Data(context, (Data) semanticObject); 
				return; 
			case SystemDescriptorPackage.DESCRIPTOR:
				sequence_Descriptor(context, (Descriptor) semanticObject); 
				return; 
			case SystemDescriptorPackage.EMPTY_ARRAY:
				sequence_EmptyArray(context, (EmptyArray) semanticObject); 
				return; 
			case SystemDescriptorPackage.EMPTY_OBJECT:
				sequence_EmptyObject(context, (EmptyObject) semanticObject); 
				return; 
			case SystemDescriptorPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case SystemDescriptorPackage.METADATA:
				sequence_Metadata(context, (Metadata) semanticObject); 
				return; 
			case SystemDescriptorPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case SystemDescriptorPackage.OBJECT:
				sequence_Object(context, (com.ngc.seaside.systemdescriptor.systemDescriptor.Object) semanticObject); 
				return; 
			case SystemDescriptorPackage.OBJECT_VALUE:
				sequence_ObjectValue(context, (ObjectValue) semanticObject); 
				return; 
			case SystemDescriptorPackage.PACKAGE:
				sequence_Package(context, (com.ngc.seaside.systemdescriptor.systemDescriptor.Package) semanticObject); 
				return; 
			case SystemDescriptorPackage.TERMINAL_OBJECT:
				sequence_TerminalObject(context, (TerminalObject) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Array returns Array
	 *     ObjectValue returns Array
	 *
	 * Constraint:
	 *     (firstItem=ObjectValue items+=ObjectValue*)
	 */
	protected void sequence_Array(ISerializationContext context, Array semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Data returns Data
	 *     Element returns Data
	 *
	 * Constraint:
	 *     name=UnqualifiedName
	 */
	protected void sequence_Data(ISerializationContext context, Data semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SystemDescriptorPackage.Literals.ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SystemDescriptorPackage.Literals.ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataAccess().getNameUnqualifiedNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Descriptor returns Descriptor
	 *
	 * Constraint:
	 *     (package=Package elements+=Element+)
	 */
	protected void sequence_Descriptor(ISerializationContext context, Descriptor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EmptyArray returns EmptyArray
	 *     ObjectValue returns EmptyArray
	 *
	 * Constraint:
	 *     isEmpty?='[]'
	 */
	protected void sequence_EmptyArray(ISerializationContext context, EmptyArray semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SystemDescriptorPackage.Literals.EMPTY_ARRAY__IS_EMPTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SystemDescriptorPackage.Literals.EMPTY_ARRAY__IS_EMPTY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEmptyArrayAccess().getIsEmptyLeftSquareBracketRightSquareBracketKeyword_0(), semanticObject.isIsEmpty());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EmptyObject returns EmptyObject
	 *     ObjectValue returns EmptyObject
	 *
	 * Constraint:
	 *     isEmpty?='{}'
	 */
	protected void sequence_EmptyObject(ISerializationContext context, EmptyObject semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SystemDescriptorPackage.Literals.EMPTY_OBJECT__IS_EMPTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SystemDescriptorPackage.Literals.EMPTY_OBJECT__IS_EMPTY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEmptyObjectAccess().getIsEmptyLeftCurlyBracketRightCurlyBracketKeyword_0(), semanticObject.isIsEmpty());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=[Element|QualifiedName]
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SystemDescriptorPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SystemDescriptorPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceElementQualifiedNameParserRuleCall_1_0_1(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Metadata returns Metadata
	 *
	 * Constraint:
	 *     (type='metadata' json=Object?)
	 */
	protected void sequence_Metadata(ISerializationContext context, Metadata semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *     Element returns Model
	 *
	 * Constraint:
	 *     name=UnqualifiedName
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SystemDescriptorPackage.Literals.ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SystemDescriptorPackage.Literals.ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModelAccess().getNameUnqualifiedNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ObjectValue returns ObjectValue
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_ObjectValue(ISerializationContext context, ObjectValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SystemDescriptorPackage.Literals.OBJECT_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SystemDescriptorPackage.Literals.OBJECT_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectValueAccess().getValueSTRINGTerminalRuleCall_0_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Object returns Object
	 *     ObjectValue returns Object
	 *
	 * Constraint:
	 *     (firstObject=TerminalObject objects+=TerminalObject*)
	 */
	protected void sequence_Object(ISerializationContext context, com.ngc.seaside.systemdescriptor.systemDescriptor.Object semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Package returns Package
	 *
	 * Constraint:
	 *     name=QualifiedName
	 */
	protected void sequence_Package(ISerializationContext context, com.ngc.seaside.systemdescriptor.systemDescriptor.Package semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SystemDescriptorPackage.Literals.PACKAGE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SystemDescriptorPackage.Literals.PACKAGE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPackageAccess().getNameQualifiedNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TerminalObject returns TerminalObject
	 *
	 * Constraint:
	 *     (element=STRING content=ObjectValue)
	 */
	protected void sequence_TerminalObject(ISerializationContext context, TerminalObject semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SystemDescriptorPackage.Literals.TERMINAL_OBJECT__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SystemDescriptorPackage.Literals.TERMINAL_OBJECT__ELEMENT));
			if (transientValues.isValueTransient(semanticObject, SystemDescriptorPackage.Literals.TERMINAL_OBJECT__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SystemDescriptorPackage.Literals.TERMINAL_OBJECT__CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTerminalObjectAccess().getElementSTRINGTerminalRuleCall_0_0(), semanticObject.getElement());
		feeder.accept(grammarAccess.getTerminalObjectAccess().getContentObjectValueParserRuleCall_2_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
}
