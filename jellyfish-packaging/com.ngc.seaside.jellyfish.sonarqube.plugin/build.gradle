apply plugin: 'com.ngc.seaside.repository'
apply plugin: 'com.iadams.sonar-packaging'

dependencies {
   // Do not use the new scopes (api, implementation, etc) here.
   // Use the old compile scope because the sonar-packaging plugin
   // will only embed dependencies that are under the compile scope.
   compile(project(':jellyfish')) {
      // Do not include the custom SLF4J bindings.  This is because Sonarqube has its own SLF4J bindings and this can
      // cause a conflict.  The Sonarqube code itself casts the SL4J loggers to a specific binding (a logback logger)
      // so attempting to use any other type of binding will cause exceptions.
      exclude group: 'com.ngc.blocs', module: 'service.log.impl.common.slf4jlogservicebridge'
   }

   compile "com.ngc.seaside:jellyfish.api:$version"
   compile "com.ngc.seaside:jellyfish.service.api:$version"
   compile "com.ngc.seaside:guice.modules:$version"
   compile "com.ngc.seaside:systemdescriptor.model.api:$version"
   compile "com.ngc.seaside:systemdescriptor.service.api:$version"
   compile "com.ngc.seaside:systemdescriptor.service.impl.xtext:$version"
   compile "com.ngc.seaside:jellyfish.cli.command.analyze:$version"

   compile "com.ngc.seaside:systemdescriptor.service.impl.m2repositoryservice:$version"
   compile "com.ngc.blocs:service.api:$blocsVersion"
   compile "com.google.guava:guava:$guavaVersion"
   compile "com.google.inject:guice:$guiceVersion"
   // Make sure this has a scope of provided.
   provided "org.sonarsource.sonarqube:sonar-plugin-api:$sonarqubeVersion"

   // This is only used for an IT to make sure all findings are registered correctly.
   testCompile "com.ngc.seaside:jellyfish.cli.command.analyzeinputsoutputs:$version"
   testCompile "junit:junit:$junitVersion"
   testCompile "org.mockito:mockito-core:$mockitoVersion"
   // Include the SLF4J logging adapter so we can see logs during test execution.
   testCompile "ch.qos.logback:logback-core:1.1.7"
   testCompile "ch.qos.logback:logback-classic:1.1.7"
}

sonarPackaging {
   pluginKey = 'systemdescriptor'
   pluginName = 'SonarSystemDescriptor'
   pluginClass = 'com.ngc.seaside.jellyfish.sonarqube.JellyfishPlugin'
   pluginDescription = 'Adds support for scanning System Descriptor projects.'
   pluginUrl = ''
   pluginSourceUrl = 'https://github.ms.northgrum.com/CEACIDE/jellyfish'
}

// Build a file that lists all the modules to use when running Jellyfish.  We do this because classpath scanning
// for all instances of com.google.inject.Module declared via a ServiceLoader doesn't work within Sonarqube because
// Sonarqube uses classloader isolation to keep plugins separate.  Instead, we build the list of all modules at
// build time and just load it at runtime.
tasks.create('buildModuleDependencyFile').doLast {
   def destinationDir = "${project.buildDir.absolutePath}/dependencies"
   def tmpDir = project.mkdir("${destinationDir}/tmp").absolutePath
   def filenameToExtract = 'META-INF/services/com.google.inject.Module'

   def guiceModulesFile = project.file("${project.buildDir.absolutePath}/resources/main/guice-modules")
   guiceModulesFile.parentFile.mkdirs()
   guiceModulesFile.createNewFile()

   def modules = new HashSet<String>()

   configurations.compile.files.forEach { file ->
      if (file.path.endsWith('.jar') && project.file(file.path).exists()) {
         project.copy {
            from(zipTree(file.path)) {
               include "**/${filenameToExtract}"
               includeEmptyDirs = false
            }
            into tmpDir
         }

         def moduleFile = project.file("${tmpDir}/${filenameToExtract}")
         if (moduleFile.exists()) {
            modules.addAll(moduleFile.readLines()
                                 .stream()
                                 .map { line -> line.trim() }
                                 .filter { line -> !line.startsWith('#') }
                                 .filter { line -> !line.isEmpty() }
                                 .collect())
         }
      }
   }

   guiceModulesFile.write(modules.join('\n'))

   project.jar {
      from(guiceModulesFile.path)
   }
}

jar.dependsOn(buildModuleDependencyFile)
test.dependsOn(buildModuleDependencyFile)
buildModuleDependencyFile.shouldRunAfter(processResources)
