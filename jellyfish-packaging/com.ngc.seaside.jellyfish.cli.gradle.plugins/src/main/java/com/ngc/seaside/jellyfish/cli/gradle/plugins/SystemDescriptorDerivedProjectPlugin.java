/**
 * UNCLASSIFIED
 *
 * Copyright 2020 Northrop Grumman Systems Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
package com.ngc.seaside.jellyfish.cli.gradle.plugins;

import com.ngc.seaside.gradle.api.AbstractProjectPlugin;
import com.ngc.seaside.gradle.plugins.repository.SeasideRepositoryExtension;
import com.ngc.seaside.gradle.plugins.repository.SeasideRepositoryPlugin;
import com.ngc.seaside.jellyfish.api.CommonParameters;
import com.ngc.seaside.jellyfish.cli.gradle.DerivedRootProjectExtension;
import com.ngc.seaside.jellyfish.cli.gradle.JellyFishProjectGenerator;
import com.ngc.seaside.jellyfish.utilities.command.JellyfishCommandPhase;

import org.apache.commons.codec.binary.Hex;
import org.gradle.api.GradleException;
import org.gradle.api.Project;
import org.gradle.api.artifacts.Dependency;
import org.gradle.api.initialization.dsl.ScriptHandler;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.AbstractMap;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * Plugin applied to a generated project generated by jellyfish. Projects must set a {@link Project#property(String)
 * property} named {@link #COMMAND_PROPERTY_NAME} of the jellyfish command. Projects may optionally also set property
 * named {@link #ARGS_PROPERTY_NAME} to a map of extra properties to pass to the jellyfish cli. Example:
 * 
 * <pre>
 * ext {
 *    command = 'create-java-service-base'
 *    args = [system : true]
 * }
 * apply plugin: 'com.ngc.seaside.jellyfish.system-descriptor-derived'
 * </pre>
 */
public class SystemDescriptorDerivedProjectPlugin extends AbstractProjectPlugin {

   public static final String GENERATED_BUILD_GRADLE_FILE_NAME = "build.generated.gradle";
   public static final String JELLYFISH_GRADLE_PLUGINS_MODULE = "com.ngc.seaside:jellyfish.cli.gradle.plugins";
   public static final String MD5_FILE_NAME = ".cli-dependencies.md5";
   public static final String COMMAND_PROPERTY_NAME = "command";
   public static final String ARGS_PROPERTY_NAME = "args";

   @Override
   protected void doApply(Project project) {
      addRepositories(project);
      cleanGen(project);
      generate(project);
      project.apply(o -> o.from(new File(project.getProjectDir(), GENERATED_BUILD_GRADLE_FILE_NAME)));
   }

   /**
    * Runs jellyfish to generate the project, if necessary.
    */
   private void generate(Project p) {
      File generatedBuild = new File(p.getProjectDir(), GENERATED_BUILD_GRADLE_FILE_NAME);
      if (!generatedBuild.exists()) {
         p.getLogger().info(":{}:generate", p.getName());
         DerivedRootProjectExtension systemDescriptor =
                  (DerivedRootProjectExtension) p.getParent().getExtensions()
                           .getByName(SystemDescriptorDerivedRootProjectPlugin.EXTENSION_NAME);
         Dependency sdProject = systemDescriptor.getProject();
         String gav = sdProject.getGroup() + ":" + sdProject.getName() + ":" + sdProject.getVersion();
         String command = p.property(COMMAND_PROPERTY_NAME).toString();
         Map<String, String> args = new LinkedHashMap<>();
         args.put(CommonParameters.MODEL.getName(), systemDescriptor.getModel());
         args.put(CommonParameters.DEPLOYMENT_MODEL.getName(), systemDescriptor.getDeploymentModel());
         args.put(CommonParameters.GROUP_ARTIFACT_VERSION.getName(), gav);
         args.put(CommonParameters.OUTPUT_DIRECTORY.getName(), p.getRootDir().getAbsolutePath());
         args.put(CommonParameters.UPDATE_GRADLE_SETTING.getName(), "false");
         args.put(CommonParameters.PHASE.getName(), JellyfishCommandPhase.DEFERRED.toString());

         Map<?, ?> extraArgs = (Map<?, ?>) p.findProperty(ARGS_PROPERTY_NAME);
         if (extraArgs != null) {
            for (Entry<?, ?> entry : extraArgs.entrySet()) {
               Object key = entry.getKey();
               Object value = entry.getValue();
               if (key != null && value != null) {
                  args.put(key.toString(), value.toString());
               }
            }
         }
         // Note when running Jellyfish from Gradle, we are always running in the deferred phase.
         new JellyFishProjectGenerator(p.getLogger())
                  .setCommand(command)
                  .setArguments(args)
                  .generate();
      }
   }

   /**
    * Deletes the generated files, if necessary. This will occur when gradle was explicitly run with the clean-gen
    * task or when jellyfish-cli or the system descriptor has changed.
    */
   private void cleanGen(Project p) {
      DerivedRootProjectExtension systemDescriptor = (DerivedRootProjectExtension) p.getParent().getExtensions()
               .getByName(SystemDescriptorDerivedRootProjectPlugin.EXTENSION_NAME);
      Dependency sdProject = systemDescriptor.getProject();

      String gav = sdProject.getGroup() + ":" + sdProject.getName() + ":" + sdProject.getVersion();
      Map<?, ?> extraArgs = (Map<?, ?>) p.findProperty(ARGS_PROPERTY_NAME);
      String extraArgsParam = null;
      if (extraArgs != null) {
         extraArgsParam = extraArgs.entrySet()
                  .stream()
                  .filter(entry -> entry.getKey() != null && entry.getValue() != null)
                  .map(entry -> new AbstractMap.SimpleImmutableEntry<>(entry.getKey().toString(),
                           entry.getValue().toString()))
                  .sorted(Comparator.comparing(Entry::getKey))
                  .map(entry -> entry.getKey() + ":" + entry.getValue())
                  .collect(Collectors.joining(","));
      }
      // Generate md5 for jellyfish-cli dependency and its transitive dependencies
      String md5 = generateMD5(findCliDependencyFiles(p),
               findSdDependencyFiles(p, systemDescriptor),
               gav,
               systemDescriptor.getModel(),
               systemDescriptor.getDeploymentModel(),
               extraArgsParam);
      File md5File = new File(p.getProjectDir(), MD5_FILE_NAME);
      String md5FileText = null;
      if (md5File.exists()) {
         try {
            md5FileText = new String(Files.readAllBytes(md5File.toPath()), StandardCharsets.UTF_8);
         } catch (IOException e) {
            // ignore
         }
      }
      boolean shouldCleanGen = !Objects.equals(md5FileText, md5)
               || p.getGradle().getStartParameter().getTaskNames()
                        .contains(SystemDescriptorDerivedRootProjectPlugin.CLEAN_GEN_TASK_NAME);
      if (shouldCleanGen) {
         p.getLogger().info(":${p.name}:clean-gen");
         p.delete("src");
         p.delete(GENERATED_BUILD_GRADLE_FILE_NAME);
         try {
            Files.write(md5File.toPath(), md5.getBytes(StandardCharsets.UTF_8));
         } catch (IOException e) {
            throw new GradleException("Unable to write to file " + md5File, e);
         }
      }
   }

   private Set<File> findCliDependencyFiles(Project p) {
      String[] ga = JELLYFISH_GRADLE_PLUGINS_MODULE.split(":");
      String cliGroup = ga[0];
      String cliName = ga[1];

      Dependency cliDependency;
      Project parentProject = p;
      while (true) {
         cliDependency = parentProject.getBuildscript()
                  .getConfigurations()
                  .getByName(ScriptHandler.CLASSPATH_CONFIGURATION)
                  .getDependencies()
                  .stream()
                  .filter(dependency -> cliGroup.equals(dependency.getGroup())
                           && cliName.equals(dependency.getName()))
                  .findAny()
                  .orElse(null);
         if (cliDependency != null) {
            break;
         }
         parentProject = parentProject.getParent();
         if (parentProject == null) {
            throw new GradleException(
                     "com.ngc.seaside.jellyfish.system-descriptor-derived plugin requires "
                              + JELLYFISH_GRADLE_PLUGINS_MODULE + " on the classpath");
         }
      }
      return parentProject.getBuildscript().getConfigurations().getByName(ScriptHandler.CLASSPATH_CONFIGURATION)
               .files(cliDependency);
   }

   private Set<File> findSdDependencyFiles(Project p, DerivedRootProjectExtension systemDescriptor) {
      return p.getConfigurations().detachedConfiguration(systemDescriptor.getProject()).getFiles();
   }

   private String generateMD5(Set<File> cliFiles, Set<File> sdFiles, String... params) {
      MessageDigest digest;
      try {
         digest = MessageDigest.getInstance("MD5");
      } catch (NoSuchAlgorithmException e) {
         throw new AssertionError();
      }
      Stream.concat(cliFiles.stream(), sdFiles.stream())
               .sorted(Comparator.comparing(File::getName))
               .forEach(file -> {
                  try (FileInputStream fis = new FileInputStream(file)) {
                     byte[] buffer = new byte[4096];
                     int nread = 0;
                     while ((nread = fis.read(buffer)) != -1) {
                        digest.update(buffer, 0, nread);
                     }
                  } catch (IOException e) {
                     throw new GradleException("Unable to read file " + file, e);
                  }
               });
      for (String param : params) {
         if (param == null) {
            param = "";
         }
         digest.update(param.getBytes());
      }
      return Hex.encodeHexString(digest.digest());
   }

   private void addRepositories(Project project) {
      project.getPlugins().apply(SeasideRepositoryPlugin.class);
      SeasideRepositoryExtension extension =
               (SeasideRepositoryExtension) project.getExtensions().getByName(SeasideRepositoryExtension.NAME);
      extension.configure();
   }
}
